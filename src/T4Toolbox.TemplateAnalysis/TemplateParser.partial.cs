// <copyright file="TemplateParser.partial.cs" company="Oleg Sych">
//  Copyright © Oleg Sych. All Rights Reserved.
// </copyright>

namespace T4Toolbox.TemplateAnalysis
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Diagnostics;
    using Microsoft.VisualStudio.Text;

    /// <summary>
    /// Parser class generated by GPPG.
    /// </summary>
    internal partial class TemplateParser
    {
        private static readonly Dictionary<int, string> TokenAliases = new Dictionary<int, string>
        {
            { (int)SyntaxKind.AttributeName,        "attribute name" },
            { (int)SyntaxKind.AttributeValue,       "attribute value" },
            { (int)SyntaxKind.BlockEnd,             "#>" },
            { (int)SyntaxKind.ClassBlockStart,      "<#+" },
            { (int)SyntaxKind.Code,                 "code" },
            { (int)SyntaxKind.DirectiveBlockStart,  "<#@" }, 
            { (int)SyntaxKind.DirectiveName,        "directive name" }, 
            { (int)SyntaxKind.DoubleQuote,          "\"" },
            { (int)SyntaxKind.EOF,                  "end of file" }, 
            { (int)SyntaxKind.Equals,               "=" },
            { (int)SyntaxKind.ExpressionBlockStart, "<#=" },
            { (int)SyntaxKind.StatementBlockStart,  "<#" }
        };

        private readonly List<TemplateError> errors = new List<TemplateError>();
        
        public TemplateParser(TemplateScanner scanner)
            : base(scanner)
        {
            // Initialize the "aliases" manually here instead of the .y file to workaround the problem 
            // in GPPG code generation, which stores quotation marks in in the dictionary values.
            TemplateParser.aliases = TokenAliases;

            scanner.Parser = this;
        }

        public IReadOnlyList<TemplateError> Errors
        {
            get { return this.errors; }
        }

        public Template Template { get; private set; }

        internal void Error(string message)
        {
            SyntaxNode current = this.Scanner.yylval;
            this.errors.Add(new TemplateError(message, current.Span, current.Position));
        }

        private sealed class NodeBuilder : SyntaxNode
        {
            private readonly List<SyntaxNode> childNodes = new List<SyntaxNode>();

            public override SyntaxKind Kind
            {
                get { throw new NotImplementedException(); }
            }

            public override Position Position
            {
                get { throw new NotImplementedException(); }
            }

            public override Span Span
            {
                get { throw new NotImplementedException(); }
            }

            public void AddChildNode(SyntaxNode childNode)
            {
                Debug.Assert(childNode != null, "childNode");
                this.childNodes.Add(childNode);
            }

            public override IEnumerable<SyntaxNode> ChildNodes()
            {
                return this.childNodes;
            }

            public override IEnumerable<TemplateError> Validate()
            {
                throw new NotImplementedException();
            }

            protected internal override void Accept(SyntaxNodeVisitor visitor)
            {
                throw new NotImplementedException();
            }
        }
    }
}